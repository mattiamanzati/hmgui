{"version":3,"sources":["serviceWorker.ts","lib/data/hlist.ts","lib/core/context.ts","lib/core/dsl.ts","lib/data/next.ts","lib/core/widget.ts","lib/widgets.ts","lib/attributes.ts","lib/react/renderer.tsx","lib/sample.tsx","index.tsx"],"names":["Boolean","window","location","hostname","match","nil","type","length","cons","value","prev","pop","list","equals","a","b","currA","currB","Error","getLast","fa","O","toArray","len","r","Array","l","i","toString","map","f","join","initialWidgetBuilderState","currentId","hlist","label","enabled","initialWidgetState","activeId","activeIdIsAlive","activeIdWasPressedBefore","pressedId","focusedId","inputBuffer","autoFocus","getEnabled","ctx","isActiveIdStale","state","optionHList","setActiveId","Object","objectSpread","setActiveIdIsAlive","setPressedId","setFocusedId","setInputBuffer","isActive","id","isCurrentlyActive","isCurrentlyFocused","canActivate","text","input","cont","suspendAndResume","effect","fold","onContinue","onResumeAndContinue","onHalt","widget","H","ui","compare","noEventHandler","_","tr","strings","_len","arguments","values","_key","R","D","tick","W","handleContainerEvents","widgets","dsl","initialState","transforms","w","currentState","currentIndex","proposedState","container","builders","pipe","A","sequence","children","handleInputEvents","onChange","valid","isFormatValid","C","canDeactivate","N","bufferValue","console","log","I","alwaysTrue","string","StateContext","React","RX","render","props","react","RenderInput","assign","key","RenderContainer","RenderText","RenderButton","JSON","stringify","translate","t","s","useObservable","observable$","initialValue","_React$useState","_React$useState2","slicedToArray","update","subscribe","unsubscribe","state$","dispatch","idSerialized","onChangeText","newText","onFocus","onBlur","ref","isActive$","rxOp","isFocused$","rawValue$","isFocused","rawValue","current","focus","TextInput","editable","undefined","autoCapitalize","displayName","Text","Button","onPress","title","RenderDsl","AppRunner","_React$Component","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","app","eventLoop","startedAt","Date","getTime","keepAlive","frameProcessed","stateList","requestedState","newState","runEffect","getApp","push","timeTaken","setState","next","inherits","createClass","builtApp","startedAt2","timeTaken2","_this2","Provider","spamTest","appModel","ReactDOM","react_default","createElement","renderer_AppRunner","model","_templateObject","name","slice","concat","newValue","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.31c30a26.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import * as O from \"fp-ts/lib/Option\";\r\n\r\n// HList implementation\r\ninterface Nil {\r\n  type: \"nil\";\r\n  length: 0;\r\n}\r\nexport const nil: Nil = { type: \"nil\", length: 0 };\r\ninterface Cons<A> {\r\n  type: \"cons\";\r\n  value: A;\r\n  length: number;\r\n  prev: HList<A>;\r\n}\r\nexport type HList<A> = Cons<A> | Nil;\r\nexport const cons: <A>(value: A, prev: HList<A>) => HList<A> = (\r\n  value,\r\n  prev\r\n) => ({ type: \"cons\", value, prev, length: prev.length + 1 });\r\nexport const pop: <A>(list: HList<A>) => HList<A> = list =>\r\n  list.type === \"nil\" ? list : list.prev;\r\n\r\nexport function equals<A>(a: HList<A>, b: HList<A>) {\r\n  let currA = a;\r\n  let currB = b;\r\n  while (true) {\r\n    switch (currA.type) {\r\n      case \"nil\":\r\n        return currB.type === \"nil\";\r\n      case \"cons\":\r\n        if (currB.type === \"cons\" && currA.value === currB.value) {\r\n          currA = currA.prev;\r\n          currB = currB.prev;\r\n        } else {\r\n          return false;\r\n        }\r\n        break;\r\n      default:\r\n        throw Error(\"WTF!\");\r\n    }\r\n  }\r\n}\r\n\r\nexport const getLast: <A>(fa: HList<A>) => O.Option<A> = fa =>\r\n  fa.type === \"nil\" ? O.none : O.some(fa.value);\r\n\r\nexport const toArray = <A>(list: HList<A>): Array<A> => {\r\n  const len = list.length;\r\n  const r: Array<A> = new Array(len);\r\n  let l: HList<A> = list;\r\n  let i = 1;\r\n  while (l.type !== \"nil\") {\r\n    r[len - i] = l.value;\r\n    i++;\r\n    l = l.prev;\r\n  }\r\n  return r;\r\n};\r\n\r\nexport const toString = <A>(list: HList<A>): string => {\r\n  return toArray(list)\r\n    .map(f => \"\" + f)\r\n    .join(\"/\");\r\n};\r\n","import * as hlist from \"../data/hlist\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\n\r\nexport type ID = hlist.HList<string>;\r\n\r\nexport interface WidgetBuilderState {\r\n  currentId: ID;\r\n  label: O.Option<string>\r\n  enabled: boolean\r\n}\r\nexport const initialWidgetBuilderState: WidgetBuilderState = {\r\n  currentId: hlist.nil,\r\n  label: O.none,\r\n  enabled: true\r\n};\r\n\r\nexport interface WidgetState {\r\n  pressedId: O.Option<ID>; // ID of the widget being pressed\r\n  focusedId: O.Option<ID>; // ID of the widget which has currently focus, may be different from the active one.\r\n  autoFocus: boolean      // first focusable widget will acquire focus\r\n\r\n  activeId: O.Option<ID>; // ID of the widget which is currently active, meaning that edit can occur\r\n  activeIdIsAlive: O.Option<ID> // tracks if the active ID is actually interactive, if not, application will forcefully blur away.\r\n  activeIdWasPressedBefore: boolean;\r\n  inputBuffer: O.Option<string>;\r\n}\r\nexport const initialWidgetState: WidgetState = {\r\n  activeId: O.none,\r\n  activeIdIsAlive: O.none,\r\n  activeIdWasPressedBefore: false,\r\n\r\n  pressedId: O.none,\r\n  focusedId: O.none,\r\n  inputBuffer: O.none,\r\n  autoFocus: true\r\n};\r\n\r\nexport const pushId: (\r\n  id: string\r\n) => (ctx: WidgetBuilderState) => WidgetBuilderState = id => ctx => ({\r\n  ...ctx,\r\n  currentId: hlist.cons(id, ctx.currentId)\r\n});\r\nexport const popId: () => (\r\n  ctx: WidgetBuilderState\r\n) => WidgetBuilderState = () => ctx => ({\r\n  ...ctx,\r\n  currentId: hlist.pop(ctx.currentId)\r\n});\r\nexport const getEnabled: (\r\n  ctx: WidgetBuilderState\r\n) => boolean = ctx => ctx.enabled\r\nexport const setEnabled: (enabled: boolean) => (\r\n  ctx: WidgetBuilderState\r\n) => WidgetBuilderState = (enabled) => ctx => ({\r\n  ...ctx,\r\n  enabled\r\n});\r\n\r\nexport function newFrame(state: WidgetState): WidgetState {\r\n  return pipe(\r\n    state,\r\n    setActiveIdIsAlive(O.none)\r\n  )\r\n}\r\n\r\nexport function isActiveIdStale(state: WidgetState): boolean {\r\n  return O.isSome(state.activeId) && O.isSome(state.activeIdIsAlive) && !optionHList.equals(state.activeId, state.activeIdIsAlive)\r\n}\r\n\r\nexport function setActiveId(\r\n  activeId: O.Option<ID>\r\n): (state: WidgetState) => WidgetState {\r\n  return state => ({\r\n    ...state,\r\n    activeId,\r\n    activeIdIsAlive: activeId,\r\n    activeIdWasPressedBefore: optionHList.equals(activeId, state.activeId)\r\n      ? state.activeIdWasPressedBefore\r\n      : false,\r\n    inputBuffer: optionHList.equals(activeId, state.activeId)\r\n      ? state.inputBuffer\r\n      : O.none\r\n  });\r\n}\r\n\r\nexport function setActiveIdIsAlive(\r\n  activeIdIsAlive: O.Option<ID>\r\n): (state: WidgetState) => WidgetState {\r\n  return state => ({ ...state, activeIdIsAlive })\r\n}\r\n\r\nexport function setActiveIdWasPressedBefore(activeIdWasPressedBefore: boolean): (state: WidgetState) => WidgetState{\r\n  return state => ({ ...state, activeIdWasPressedBefore })\r\n}\r\nexport function setPressedId(\r\n  pressedId: O.Option<ID>\r\n): (state: WidgetState) => WidgetState {\r\n  return state => ({ ...state, pressedId });\r\n}\r\n\r\nexport function setFocusedId(\r\n  focusedId: O.Option<ID>\r\n): (state: WidgetState) => WidgetState {\r\n  return state => ({ ...state, focusedId });\r\n}\r\nexport function setAutoFocus(autoFocus: boolean): (state: WidgetState) => WidgetState{\r\n  return state => ({ ...state, autoFocus })\r\n}\r\nexport function setInputBuffer(\r\n  inputBuffer: O.Option<string>\r\n): (state: WidgetState) => WidgetState {\r\n  return state => ({ ...state, inputBuffer });\r\n}\r\n\r\nconst optionHList = O.getEq(hlist);\r\n\r\nexport function isActive(id: ID, state: WidgetState) {\r\n  return optionHList.equals(O.some(id), state.activeId);\r\n}\r\nexport function isFocused(id: ID, state: WidgetState) {\r\n  return optionHList.equals(O.some(id), state.focusedId);\r\n}\r\n\r\nexport function isCurrentlyActive(\r\n  ctx: WidgetBuilderState,\r\n  state: WidgetState\r\n): boolean {\r\n  return isActive(ctx.currentId, state);\r\n}\r\n\r\nexport function isCurrentlyPressed(\r\n  ctx: WidgetBuilderState,\r\n  state: WidgetState\r\n): boolean {\r\n  return optionHList.equals(O.some(ctx.currentId), state.pressedId);\r\n}\r\n\r\nexport function isCurrentlyFocused(\r\n  ctx: WidgetBuilderState,\r\n  state: WidgetState\r\n): boolean {\r\n  return optionHList.equals(O.some(ctx.currentId), state.focusedId);\r\n}\r\n\r\nexport function canActivate(\r\n  ctx: WidgetBuilderState,\r\n  state: WidgetState\r\n): boolean {\r\n  return O.isNone(state.activeId) && !isCurrentlyActive(ctx, state);\r\n}\r\nexport function canDeactivate(\r\n  ctx: WidgetBuilderState,\r\n  state: WidgetState\r\n): boolean {\r\n  return isCurrentlyActive(ctx, state);\r\n}\r\n","import * as hlist from \"../data/hlist\";\r\n\r\nexport type TranslableString = {\r\n  type: \"translable_string\";\r\n  strings: TemplateStringsArray;\r\n  values: string[];\r\n};\r\n\r\nexport const tr: (\r\n  strings: TemplateStringsArray,\r\n  ...values: string[]\r\n) => TranslableString = (strings, ...values) => ({\r\n  type: \"translable_string\",\r\n  strings,\r\n  values\r\n});\r\n\r\nexport type ID = hlist.HList<string>;\r\n\r\ntype LocationDSL = { row: number; column: number; flex: number };\r\n\r\nexport type DSL =\r\n  | { type: \"text\"; id: ID; text: TranslableString }\r\n  | { type: \"button\"; id: ID; text: TranslableString }\r\n  | { type: \"container\"; id: ID; children: DSL[] }\r\n  | { type: \"input\"; id: ID; value: string ; enabled: boolean};\r\n\r\nexport const text: (id: ID, text: TranslableString) => DSL = (id, text) => ({\r\n  type: \"text\",\r\n  id,\r\n  text\r\n});\r\nexport const container: (id: ID, children: DSL[]) => DSL = (id, children) => ({\r\n  type: \"container\",\r\n  id,\r\n  children\r\n});\r\nexport const button: (id: ID, text: TranslableString) => DSL = (id, text) => ({\r\n  type: \"button\",\r\n  id,\r\n  text\r\n});\r\nexport const input: (id: ID, value: string, enabled: boolean) => DSL = (\r\n  id,\r\n  value,\r\n  enabled\r\n) => ({ type: \"input\", id, value, enabled });\r\n","import { URIS, Kind } from \"fp-ts/lib/HKT\";\r\n\r\nexport type Next<U extends URIS, A> =\r\n  | { type: \"halt\" }\r\n  | { type: \"continue\"; state: A }\r\n  | { type: \"suspendAndResume\"; effect: Kind<U, A> };\r\n\r\nexport const halt: <U extends URIS, A>() => Next<U, A> = () => ({\r\n  type: \"halt\"\r\n});\r\nexport const cont: <U extends URIS, A>(state: A) => Next<U, A> = state => ({\r\n  type: \"continue\",\r\n  state\r\n});\r\nexport const suspendAndResume: <U extends URIS, A>(\r\n  effect: Kind<U, A>\r\n) => Next<U, A> = effect => ({ type: \"suspendAndResume\", effect });\r\n\r\nexport const fold: <U extends URIS, A, B>(\r\n  onContinue: (state: A) => B,\r\n  onSuspendAndResume: (effect: Kind<U, A>) => B,\r\n  onHalt: () => B\r\n) => (fa: Next<U, A>) => B = (\r\n  onContinue,\r\n  onResumeAndContinue,\r\n  onHalt\r\n) => fa => {\r\n  switch (fa.type) {\r\n    case \"continue\":\r\n      return onContinue(fa.state);\r\n    case \"suspendAndResume\":\r\n      return onResumeAndContinue(fa.effect);\r\n    case \"halt\":\r\n      return onHalt();\r\n    default:\r\n      throw Error(\"WTF!\");\r\n  }\r\n};\r\n\r\nexport const reduce: <U extends URIS, A>(\r\n  items: ((state: A) => Next<U, A>)[]\r\n) => (initialState: A) => Next<U, A> = transforms => initialState => {\r\n  let currentState = initialState;\r\n  let currentIndex = 0;\r\n  while (transforms.length > currentIndex) {\r\n    const proposedState = transforms[currentIndex](currentState);\r\n    switch (proposedState.type) {\r\n      case \"halt\":\r\n        break;\r\n      case \"continue\":\r\n        currentState = proposedState.state;\r\n        break;\r\n      case \"suspendAndResume\":\r\n        return proposedState;\r\n      default:\r\n        throw Error(\"WTF!\");\r\n    }\r\n    currentIndex++;\r\n  }\r\n  return currentState !== initialState ? cont(currentState) : halt();\r\n};\r\n","import * as R from \"fp-ts/lib/Reader\";\r\nimport * as C from \"./context\";\r\nimport * as D from \"./dsl\";\r\nimport * as O from \"fp-ts/lib/Ord\";\r\nimport * as H from \"../data/hlist\";\r\nimport * as N from \"../data/next\";\r\n\r\n\r\nexport interface Widget {\r\n  ui: D.DSL;\r\n  tick: (dsl: D.DSL) => (state: C.WidgetState) => N.Next<\"IO\", C.WidgetState>;\r\n}\r\n\r\nexport interface WidgetBuilder extends R.Reader<C.WidgetBuilderState, Widget> {}\r\n\r\nexport const widget: O.Ord<Widget> = {\r\n  equals: (a, b) => H.equals(a.ui.id, b.ui.id),\r\n  compare: (a, b) => 0\r\n};\r\n\r\nexport const noEventHandler: (dsl: D.DSL) => (state: C.WidgetState) => N.Next<\"IO\", C.WidgetState> = _ => _ => N.halt()","import * as C from \"./core/context\";\r\nimport * as D from \"./core/dsl\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as R from \"fp-ts/lib/Reader\";\r\nimport * as A from \"fp-ts/lib/Array\";\r\nimport * as I from \"fp-ts/lib/IO\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport * as N from \"./data/next\";\r\nimport * as W from \"./core/widget\";\r\n\r\nexport const tr = D.tr;\r\n\r\nexport const text: (text: D.TranslableString) => W.WidgetBuilder = text =>\r\n  R.asks<C.WidgetBuilderState, W.Widget>(ctx => ({\r\n    ui: D.text(ctx.currentId, text),\r\n    tick: W.noEventHandler\r\n  }));\r\n\r\nexport const button: (\r\n  text: D.TranslableString,\r\n  onPress: () => I.IO<void>\r\n) => W.WidgetBuilder = (text, onPress) =>\r\n  R.asks<C.WidgetBuilderState, W.Widget>(ctx => ({\r\n    ui: D.button(ctx.currentId, text),\r\n    tick: _ => state => {\r\n      const canActivate = C.canActivate(ctx, state);\r\n      const isCurrentlyPressed = C.isCurrentlyPressed(ctx, state);\r\n      const isCurrentlyFocused = C.isCurrentlyFocused(ctx, state);\r\n      const wasPressedBefore = state.activeIdWasPressedBefore;\r\n      const isCurrentlyActive = C.isCurrentlyActive(ctx, state);\r\n\r\n      if (isCurrentlyPressed && !isCurrentlyFocused) {\r\n        console.log(\"button: focusing\");\r\n        return N.cont(\r\n          pipe(\r\n            state,\r\n            C.setFocusedId(O.some(ctx.currentId))\r\n          )\r\n        );\r\n      }\r\n\r\n      if (canActivate && isCurrentlyFocused && isCurrentlyPressed) {\r\n        console.log(\"button: activating\");\r\n        return N.cont(\r\n          pipe(\r\n            state,\r\n            C.setActiveId(O.some(ctx.currentId))\r\n          )\r\n        );\r\n      }\r\n\r\n      if (isCurrentlyActive && !wasPressedBefore) {\r\n        console.log(\"button: onPress\");\r\n        return N.suspendAndResume(\r\n          pipe(\r\n            onPress(),\r\n            I.map(_ =>\r\n              pipe(\r\n                state,\r\n                C.setActiveIdWasPressedBefore(true)\r\n              )\r\n            )\r\n          )\r\n        );\r\n      }\r\n\r\n      if (isCurrentlyActive && !isCurrentlyPressed) {\r\n        console.log(\"button: deactivating\");\r\n        return N.cont(\r\n          pipe(\r\n            state,\r\n            C.setActiveId(O.none)\r\n          )\r\n        );\r\n      }\r\n\r\n      return N.halt();\r\n    }\r\n  }));\r\n\r\nconst handleContainerEvents: (widgets: W.Widget[]) => (ctx: C.WidgetBuilderState) =>  (dsl: D.DSL) => (state: C.WidgetState) => N.Next<\"IO\", C.WidgetState> =\r\n  (widgets => ctx => dsl => initialState =>\r\n    N.reduce(widgets.map(w => w.tick(w.ui)))(initialState))\r\n\r\nexport const container: (builders: W.WidgetBuilder[]) => W.WidgetBuilder = ((\r\n  builders\r\n) =>\r\n  pipe(\r\n    A.array.sequence(R.reader)(builders),\r\n    R.map(A.sort(W.widget)),\r\n    R.chain(widgets =>\r\n      R.asks<C.WidgetBuilderState, W.Widget>(ctx => ({\r\n        ui: D.container(ctx.currentId, widgets.map(w => w.ui)),\r\n        tick: handleContainerEvents(widgets)(ctx)\r\n      }))\r\n    )\r\n  ));\r\n\r\nconst handleInputEvents: (value: string,\r\n  onChange: (newValue: string) => I.IO<void>,\r\n  valid: boolean,\r\n  isFormatValid: (bufferValue: string) => boolean) => (ctx: C.WidgetBuilderState) => (dsl: D.DSL) => (state: C.WidgetState) => N.Next<\"IO\", C.WidgetState> = (\r\n  ((value, onChange, valid, isFormatValid) => ctx => _ => state => {\r\n    const canActivate = C.canActivate(ctx, state);\r\n    const isCurrentlyActive = C.isCurrentlyActive(ctx, state);\r\n    const isCurrentlyFocused = C.isCurrentlyFocused(ctx, state);\r\n    const canDeactivate = C.canDeactivate(ctx, state);\r\n    const enabled = C.getEnabled(ctx);\r\n\r\n    // if disabled, forcefully deactivate\r\n    if (isCurrentlyActive && O.isNone(state.activeIdIsAlive)) {\r\n      return N.cont(C.setActiveIdIsAlive(O.some(ctx.currentId))(state));\r\n    }\r\n\r\n    // if disabled, forcefully deactivate\r\n    if (isCurrentlyActive && !enabled) {\r\n      return N.cont(\r\n        pipe(\r\n          state,\r\n          C.setActiveId(O.some(ctx.currentId))\r\n        )\r\n      );\r\n    }\r\n\r\n    // if enabled, allows logic\r\n    if (enabled) {\r\n      if (!isCurrentlyActive && isCurrentlyFocused && canActivate) {\r\n        // activate the control\r\n        return N.cont(\r\n          pipe(\r\n            state,\r\n            C.setActiveId(O.some(ctx.currentId))\r\n          )\r\n        );\r\n      } else if (isCurrentlyActive && !isCurrentlyFocused && canDeactivate) {\r\n        // if there is no pending buffer, release the control\r\n        if (O.isNone(state.inputBuffer) && valid) {\r\n          return N.cont(\r\n            pipe(\r\n              state,\r\n              C.setActiveId(O.none)\r\n            )\r\n          );\r\n        }\r\n\r\n        // check if the format of the buffer is ok\r\n        const bufferValue = O.getOrElse(() => value)(state.inputBuffer);\r\n        if (isFormatValid(bufferValue)) {\r\n          console.log(\"input: run onChange\");\r\n          return N.suspendAndResume(\r\n            pipe(\r\n              onChange(bufferValue),\r\n              I.map(() => C.setInputBuffer(O.none)(state))\r\n            )\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return N.halt();\r\n  }\r\n))\r\n\r\nexport const input: (\r\n  value: string,\r\n  onChange: (newValue: string) => I.IO<void>,\r\n  valid: boolean,\r\n  isFormatValid: (bufferValue: string) => boolean\r\n) => W.WidgetBuilder = (value, onChange, valid, isFormatValid) =>\r\n  R.asks<C.WidgetBuilderState, W.Widget>(ctx => ({\r\n    ui: D.input(ctx.currentId, value, C.getEnabled(ctx)),\r\n    tick: handleInputEvents(value, onChange, valid, isFormatValid)(ctx)\r\n  }));\r\n\r\nexport const number: (\r\n  value: number,\r\n  onChange: (newValue: number) => I.IO<void>,\r\n  valid: boolean\r\n) => W.WidgetBuilder = (value, onChange, valid) =>\r\n  input(\r\n    value.toFixed(0),\r\n    newValue => onChange(parseInt(newValue)),\r\n    valid,\r\n    value => !isNaN(parseInt(value))\r\n  );\r\n\r\nconst alwaysTrue = (value: string) => true;\r\n\r\nexport const string: (\r\n  value: string,\r\n  onChange: (newValue: string) => I.IO<void>,\r\n  valid: boolean\r\n) => W.WidgetBuilder = (value, onChange, valid) =>\r\n  input(value, onChange, valid, alwaysTrue);\r\n","import * as C from \"./core/context\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as R from \"fp-ts/lib/Reader\";\r\nimport * as W from \"./core/widget\";\r\n\r\nexport const id: (\r\n  id: string\r\n) => (widget: W.WidgetBuilder) => W.WidgetBuilder = id => widget =>\r\n  pipe(\r\n    widget,\r\n    R.local(C.pushId(id)),\r\n  );\r\n\r\nexport const enabled: (\r\n  isEnabled: boolean\r\n) => (widget: W.WidgetBuilder) => W.WidgetBuilder = isEnabled => widget =>\r\n  pipe(\r\n    widget,\r\n    R.local(C.setEnabled(isEnabled))\r\n  );\r\n","import * as React from \"react\";\r\nimport * as D from \"../core/dsl\";\r\nimport * as C from \"../core/context\";\r\nimport * as I from \"fp-ts/lib/IO\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport * as CW from \"../core/widget\";\r\nimport * as hlist from \"../data/hlist\";\r\nimport * as N from \"../data/next\";\r\nimport * as rxOp from \"rxjs/operators\";\r\nimport * as RR from \"./renderer\";\r\nimport { TextInput, Text, Button } from \"react-native\";\r\nimport * as RX from \"rxjs\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\n\r\nconst StateContext = React.createContext(RX.of(C.initialWidgetState));\r\n\r\ntype ComponentProps = {\r\n  dsl: D.DSL;\r\n  dispatch: (f: (state: C.WidgetState) => C.WidgetState) => I.IO<void>;\r\n  update: (f: (state: C.WidgetState) => C.WidgetState) => I.IO<void>;\r\n};\r\n\r\nfunction render(props: ComponentProps): JSX.Element {\r\n  switch (props.dsl.type) {\r\n    case \"input\":\r\n      return <RenderInput {...props} key={hlist.toString(props.dsl.id)} />;\r\n    case \"container\":\r\n      return <RenderContainer {...props} key={hlist.toString(props.dsl.id)} />;\r\n    case \"text\":\r\n      return <RenderText {...props} key={hlist.toString(props.dsl.id)} />;\r\n    case \"button\":\r\n      return <RenderButton {...props} key={hlist.toString(props.dsl.id)} />;\r\n  }\r\n  return <React.Fragment>{JSON.stringify(props.dsl)}</React.Fragment>;\r\n}\r\n\r\nfunction translate(t: D.TranslableString): string {\r\n  // TODO: this is just a stub, needs to handle number and date formatting in a localized way.\r\n  return t.strings.map((s, i) => s + (t.values[i] || \"\")).join(\"\");\r\n}\r\n\r\nfunction useObservable<T>(observable$: RX.Observable<T>): T | undefined;\r\nfunction useObservable<T>(observable$: RX.Observable<T>, initialValue: T): T;\r\nfunction useObservable<T>(\r\n  observable$: RX.Observable<T>,\r\n  initialValue?: T\r\n): T | undefined {\r\n  const [value, update] = React.useState<T | undefined>(initialValue);\r\n\r\n  React.useLayoutEffect(() => {\r\n    const s = observable$.subscribe(update);\r\n    return () => s.unsubscribe();\r\n  }, [observable$]);\r\n\r\n  return value;\r\n}\r\n\r\nexport const RenderInput = React.memo(function InputRenderer(\r\n  props: ComponentProps\r\n) {\r\n  const state$ = React.useContext(StateContext);\r\n  const { dispatch, update } = props;\r\n  const { id } = props.dsl;\r\n  const value = (props.dsl as any).value || \"\";\r\n  const idSerialized = hlist.toString(id);\r\n  const onChangeText = React.useMemo(\r\n    () => (newText: string) => update(C.setInputBuffer(O.some(newText)))(),\r\n    [update]\r\n  );\r\n  const onFocus = React.useMemo(\r\n    () => dispatch(C.setFocusedId(O.some(id))),\r\n    [dispatch, idSerialized]\r\n  );\r\n  const onBlur = React.useMemo(() => dispatch(C.setFocusedId(O.none)), [\r\n    dispatch,\r\n    idSerialized\r\n  ]);\r\n  const ref = React.useRef<TextInput>();\r\n\r\n  const isActive$ = React.useMemo(\r\n    () => state$.pipe(rxOp.map(state => C.isActive(id, state))),\r\n    [state$, idSerialized]\r\n  );\r\n  const isFocused$ = React.useMemo(\r\n    () => state$.pipe(rxOp.map(state => C.isFocused(id, state))),\r\n    [state$, idSerialized]\r\n  );\r\n  const rawValue$ = React.useMemo(\r\n    () =>\r\n      state$.pipe(\r\n        rxOp.map(state =>\r\n          C.isActive(id, state)\r\n            ? O.getOrElse(() => value)(state.inputBuffer)\r\n            : value\r\n        )\r\n      ),\r\n    [state$, idSerialized, value]\r\n  );\r\n\r\n  const isActive = useObservable(isActive$, false);\r\n  const isFocused = useObservable(isFocused$, false);\r\n  const rawValue = useObservable(rawValue$, value);\r\n\r\n  React.useLayoutEffect(() => {\r\n    if (isFocused && ref.current && !ref.current.isFocused()) {\r\n      ref.current.focus();\r\n      console.log(\"forced focus to\", idSerialized);\r\n    }\r\n  });\r\n\r\n  if (props.dsl.type !== \"input\") return null;\r\n\r\n  return (\r\n      <TextInput\r\n        ref={ref as any}\r\n        editable={isActive}\r\n        value={rawValue}\r\n        onChangeText={isActive ? onChangeText : undefined}\r\n        onFocus={!isFocused ? onFocus : undefined}\r\n        onBlur={isFocused ? onBlur : undefined}\r\n        autoCapitalize=\"none\"\r\n      />\r\n  );\r\n});\r\nRenderInput.displayName = 'DSL(Input)'\r\n\r\nexport const RenderText = React.memo(function TextRenderer(\r\n  props: ComponentProps\r\n) {\r\n  if (props.dsl.type !== \"text\") return null;\r\n  return <Text>{translate(props.dsl.text)}</Text>;\r\n});\r\nRenderText.displayName = 'DSL(Text)'\r\n\r\nexport const RenderButton = React.memo(function ButtonRenderer(\r\n  props: ComponentProps\r\n) {\r\n  if (props.dsl.type !== \"button\") return null;\r\n  return (\r\n    <Button\r\n      onPress={() => {\r\n        props.dispatch(C.setPressedId(O.some(props.dsl.id)))();\r\n        props.dispatch(C.setPressedId(O.none))();\r\n      }}\r\n      title={translate(props.dsl.text)}\r\n    />\r\n  );\r\n});\r\nRenderButton.displayName = 'DSL(Button)'\r\n\r\nexport const RenderContainer = React.memo(function ContainerRenderer(\r\n  props: ComponentProps\r\n) {\r\n  if (props.dsl.type !== \"container\") return null;\r\n  return (\r\n    <React.Fragment key={hlist.toString(props.dsl.id)}>\r\n      {props.dsl.children.map((dsl, i) => render({ ...props, dsl }))}\r\n    </React.Fragment>\r\n  );\r\n});\r\nRenderContainer.displayName = 'DSL(Container)'\r\n\r\nexport const RenderDsl = React.memo(function DslRenderer(\r\n  props: ComponentProps\r\n) {\r\n  return render(props);\r\n});\r\n\r\nexport class AppRunner<A> extends React.Component<\r\n  { getApp: I.IO<CW.WidgetBuilder> },\r\n  C.WidgetState\r\n> {\r\n  state = C.initialWidgetState;\r\n  state$ = new RX.BehaviorSubject(this.state);\r\n  app: CW.Widget;\r\n\r\n  constructor(props: { getApp: I.IO<CW.WidgetBuilder> }) {\r\n    super(props);\r\n    this.app = this.getApp(props);\r\n  }\r\n\r\n  getApp(props: { getApp: I.IO<CW.WidgetBuilder> }) {\r\n    const startedAt = new Date().getTime()\r\n    const builtApp = props.getApp()\r\n    const timeTaken = new Date().getTime() - startedAt\r\n    console.log(\"generating DSL took \" + timeTaken + \"ms\")\r\n\r\n    const startedAt2 = new Date().getTime()\r\n    const app = builtApp(C.initialWidgetBuilderState)\r\n    const timeTaken2 = new Date().getTime() - startedAt2\r\n    console.log(\"building DSL took \" + timeTaken2 + \"ms\")\r\n\r\n    return app;\r\n  }\r\n\r\n  eventLoop: (initialState: C.WidgetState) => C.WidgetState = initialState => {\r\n    // time tracking\r\n    const startedAt = new Date().getTime()\r\n\r\n    // each frame, we debate if the active element is actually alive\r\n    let currentState = C.newFrame(initialState);\r\n    let keepAlive = true;\r\n    let frameProcessed = 0;\r\n    let stateList: C.WidgetState[] = [];\r\n    while (keepAlive) {\r\n      // calculate next\r\n      const requestedState = this.app.tick(this.app.ui)(currentState);\r\n      // get next state by optionally perform side effects\r\n      currentState = pipe(\r\n        requestedState,\r\n        N.fold(\r\n          // nothing to do, continue with the new one\r\n          newState => newState,\r\n          // we perform the side effect, and then update the app definition\r\n          runEffect => {\r\n            const state = runEffect()\r\n            this.app = this.getApp(this.props)\r\n            return state\r\n          },\r\n          // we halt and use the current state\r\n          () => {\r\n            keepAlive = false\r\n            return currentState\r\n          }\r\n        )\r\n      )\r\n      // do not loop without end!\r\n      if(keepAlive && frameProcessed >= 20){\r\n        stateList.push(currentState)\r\n        throw new Error(\"Error while converging! Last application states are reported in console.\")\r\n      }\r\n      frameProcessed++\r\n      // did we requested to halt?\r\n      if(!keepAlive){\r\n        // we have been asked to stop processing events, but is the activeId requested still alive?\r\n        // what we do is attempt to process another frame and forcefully clear the activeId\r\n        // we do this only on activeIds because we assume that \r\n        if(C.isActiveIdStale(currentState)){\r\n          currentState = C.setActiveId(O.none)(currentState)\r\n          stateList.push(currentState)\r\n          keepAlive = true\r\n        }\r\n      }\r\n    }\r\n    // render\r\n    const timeTaken = new Date().getTime() - startedAt\r\n    console.log(\"event loop took \" + timeTaken + \"ms\")\r\n\r\n    // logs processed frames\r\n    console.log(frameProcessed + \" frames processed\")\r\n    return currentState;\r\n  };\r\n\r\n  componentWillMount() {\r\n    this.setState(state => this.eventLoop(state));\r\n  }\r\n\r\n  dispatch: (\r\n    f: (state: C.WidgetState) => C.WidgetState\r\n  ) => I.IO<void> = f => () =>\r\n    this.setState(state => {\r\n      const newState = this.eventLoop(f(state));\r\n      this.state$.next(newState);\r\n      return newState;\r\n    });\r\n\r\n  update: (\r\n    f: (state: C.WidgetState) => C.WidgetState\r\n  ) => I.IO<void> = f => () =>\r\n    this.setState(state => {\r\n      const newState = f(state);\r\n      this.state$.next(newState);\r\n      return newState;\r\n    });\r\n\r\n  render() {\r\n    return (\r\n      <StateContext.Provider value={this.state$}>\r\n        <RR.RenderDsl\r\n          dsl={this.app.ui}\r\n          dispatch={this.dispatch}\r\n          update={this.update}\r\n        />\r\n      </StateContext.Provider>\r\n    );\r\n  }\r\n}\r\n","import * as W from \"./widgets\";\r\nimport * as A from \"./attributes\";\r\nimport * as React from \"react\";\r\nimport * as I from \"fp-ts/lib/IO\";\r\nimport * as RR from \"./react/renderer\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\n\r\ntype Model = string[];\r\n\r\nlet spamTest: string[] = [];\r\nfor (let i = 0; i < 300; i++) {\r\n  spamTest.push(\"\" + i);\r\n}\r\n\r\nfunction render(model: Model) {\r\n  return (update: (newModel: Model) => I.IO<void>) =>\r\n    W.container(\r\n      spamTest.map((_, i) =>\r\n        pipe(\r\n          W.container([\r\n            pipe(\r\n              W.text(W.tr`Counter ${\"\" + i}:`),\r\n              A.id(\"label\" + i)\r\n            ),\r\n            pipe(\r\n              W.string(\r\n                model[i],\r\n                name =>\r\n                  update(\r\n                    model\r\n                      .slice(0, i)\r\n                      .concat([name])\r\n                      .concat(model.slice(i + 1))\r\n                  ),\r\n                true\r\n              ),\r\n              A.id(\"name\" + i)\r\n            )\r\n          ]),\r\n          A.id(\"div\" + i)\r\n        )\r\n      )\r\n    );\r\n}\r\n\r\nlet appModel: Model = spamTest;\r\n\r\nexport function App() {\r\n  return (\r\n    <RR.AppRunner\r\n      getApp={() => {\r\n        return render(appModel)(newValue => {\r\n          console.log(\"STATE UPDATE\", newValue);\r\n          return () => {\r\n            console.log(\"STATE UPDATED\", newValue);\r\n            appModel = newValue;\r\n          };\r\n        });\r\n      }}\r\n    />\r\n  );\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport * as S from './lib/sample'\r\n\r\nReactDOM.render(<S.App />, document.getElementById(\"root\"))\r\n\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n\r\n"],"sourceRoot":""}