{"version":3,"sources":["serviceWorker.ts","lib/data/hlist.ts","lib/core/context.ts","lib/core/dsl.ts","lib/data/next.ts","lib/core/widget.ts","lib/widgets.ts","lib/attributes.ts","lib/react/renderer.tsx","lib/sample.tsx","index.tsx"],"names":["Boolean","window","location","hostname","match","nil","type","length","cons","value","prev","pop","list","equals","a","b","currA","currB","Error","getLast","fa","O","toArray","len","r","Array","l","i","toString","map","f","join","initialWidgetBuilderState","currentId","hlist","label","enabled","initialWidgetState","activeId","pressedId","focusedId","inputBuffer","activeIdWasPressedBefore","getEnabled","ctx","setEnabled","Object","objectSpread","setActiveId","state","optionHList","setPressedId","setFocusedId","setInputBuffer","isActive","id","isCurrentlyActive","isCurrentlyFocused","canActivate","text","button","input","cont","suspendAndResume","effect","widget","H","ui","compare","immutableWidget","_","s","tr","strings","_len","arguments","values","_key","S","D","tick","onPress","C","isCurrentlyPressed","wasPressedBefore","console","log","N","pipe","I","container","builders","A","sequence","W","widgets","children","w","dsl","initialState","transforms","currentState","currentIndex","proposedState","onChange","valid","isFormatValid","canDeactivate","bufferValue","number","toFixed","newValue","parseInt","isNaN","string","isEnabled","prevEnabled","StateContext","React","RX","render","props","react","RenderInput","assign","key","RenderContainer","RenderText","RenderButton","JSON","stringify","translate","t","useObservable","observable$","initialValue","_React$useState","_React$useState2","slicedToArray","update","subscribe","unsubscribe","state$","dispatch","idSerialized","onChangeText","newText","onFocus","onBlur","ref","isActive$","rxOp","isFocused$","rawValue$","isFocused","rawValue","current","focus","TextInput","editable","undefined","autoCapitalize","displayName","Text","Button","title","RenderDsl","AppRunner","_React$Component","_this","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","app","eventLoop","lastState","keepAlive","numLoops","stateList","nextState","push","getApp","warn","setState","newState","next","inherits","createClass","_this2","Provider","appModel","name","surname","age","ReactDOM","react_default","createElement","renderer_AppRunner","model","spamTest","apply","_templateObject","_templateObject2","_templateObject3","_templateObject4","_templateObject5","concat","toConsumableArray","_templateObject6","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.a79ad35d.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import * as O from \"fp-ts/lib/Option\";\r\n\r\n// HList implementation\r\ninterface Nil {\r\n  type: \"nil\";\r\n  length: 0;\r\n}\r\nexport const nil: Nil = { type: \"nil\", length: 0 };\r\ninterface Cons<A> {\r\n  type: \"cons\";\r\n  value: A;\r\n  length: number;\r\n  prev: HList<A>;\r\n}\r\nexport type HList<A> = Cons<A> | Nil;\r\nexport const cons: <A>(value: A, prev: HList<A>) => HList<A> = (\r\n  value,\r\n  prev\r\n) => ({ type: \"cons\", value, prev, length: prev.length + 1 });\r\nexport const pop: <A>(list: HList<A>) => HList<A> = list =>\r\n  list.type === \"nil\" ? list : list.prev;\r\n\r\nexport function equals<A>(a: HList<A>, b: HList<A>) {\r\n  let currA = a;\r\n  let currB = b;\r\n  while (true) {\r\n    switch (currA.type) {\r\n      case \"nil\":\r\n        return currB.type === \"nil\";\r\n      case \"cons\":\r\n        if (currB.type === \"cons\" && currA.value === currB.value) {\r\n          currA = currA.prev;\r\n          currB = currB.prev;\r\n        } else {\r\n          return false;\r\n        }\r\n        break;\r\n      default:\r\n        throw Error(\"WTF!\");\r\n    }\r\n  }\r\n}\r\n\r\nexport const getLast: <A>(fa: HList<A>) => O.Option<A> = fa =>\r\n  fa.type === \"nil\" ? O.none : O.some(fa.value);\r\n\r\nexport const toArray = <A>(list: HList<A>): Array<A> => {\r\n  const len = list.length;\r\n  const r: Array<A> = new Array(len);\r\n  let l: HList<A> = list;\r\n  let i = 1;\r\n  while (l.type !== \"nil\") {\r\n    r[len - i] = l.value;\r\n    i++;\r\n    l = l.prev;\r\n  }\r\n  return r;\r\n};\r\n\r\nexport const toString = <A>(list: HList<A>): string => {\r\n  return toArray(list)\r\n    .map(f => \"\" + f)\r\n    .join(\"/\");\r\n};\r\n","import * as hlist from \"../data/hlist\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\n\r\nexport type ID = hlist.HList<string>;\r\n\r\nexport interface WidgetBuilderState {\r\n  currentId: ID;\r\n  label: O.Option<string>\r\n  enabled: boolean\r\n}\r\nexport const initialWidgetBuilderState: WidgetBuilderState = {\r\n  currentId: hlist.nil,\r\n  label: O.none,\r\n  enabled: true\r\n};\r\n\r\nexport interface WidgetState {\r\n  pressedId: O.Option<ID>; // ID of the widget being pressed\r\n  focusedId: O.Option<ID>; // ID of the widget which has currently focus, may be different from the active one.\r\n  activeId: O.Option<ID>; // ID of the widget which is currently active, meaning that edit can occur\r\n  activeIdWasPressedBefore: boolean;\r\n  inputBuffer: O.Option<string>;\r\n}\r\nexport const initialWidgetState: WidgetState = {\r\n  activeId: O.none,\r\n  pressedId: O.none,\r\n  focusedId: O.none,\r\n  inputBuffer: O.none,\r\n  activeIdWasPressedBefore: false\r\n};\r\n\r\nexport const pushId: (\r\n  id: string\r\n) => (ctx: WidgetBuilderState) => WidgetBuilderState = id => ctx => ({\r\n  ...ctx,\r\n  currentId: hlist.cons(id, ctx.currentId)\r\n});\r\nexport const popId: () => (\r\n  ctx: WidgetBuilderState\r\n) => WidgetBuilderState = () => ctx => ({\r\n  ...ctx,\r\n  currentId: hlist.pop(ctx.currentId)\r\n});\r\nexport const getEnabled: (\r\n  ctx: WidgetBuilderState\r\n) => boolean = ctx => ctx.enabled\r\nexport const setEnabled: (enabled: boolean) => (\r\n  ctx: WidgetBuilderState\r\n) => WidgetBuilderState = (enabled) => ctx => ({\r\n  ...ctx,\r\n  enabled\r\n});\r\n\r\nexport function setActiveId(\r\n  activeId: O.Option<ID>\r\n): (state: WidgetState) => WidgetState {\r\n  return state => ({\r\n    ...state,\r\n    activeId,\r\n    inputBuffer: optionHList.equals(activeId, state.activeId)\r\n      ? state.inputBuffer\r\n      : O.none,\r\n    activeIdWasPressedBefore: optionHList.equals(activeId, state.activeId)\r\n      ? state.activeIdWasPressedBefore\r\n      : false\r\n  });\r\n}\r\n\r\nexport function setActiveIdWasPressedBefore(activeIdWasPressedBefore: boolean): (state: WidgetState) => WidgetState{\r\n  return state => ({ ...state, activeIdWasPressedBefore })\r\n}\r\nexport function setPressedId(\r\n  pressedId: O.Option<ID>\r\n): (state: WidgetState) => WidgetState {\r\n  return state => ({ ...state, pressedId });\r\n}\r\n\r\nexport function setFocusedId(\r\n  focusedId: O.Option<ID>\r\n): (state: WidgetState) => WidgetState {\r\n  return state => ({ ...state, focusedId });\r\n}\r\nexport function setInputBuffer(\r\n  inputBuffer: O.Option<string>\r\n): (state: WidgetState) => WidgetState {\r\n  return state => ({ ...state, inputBuffer });\r\n}\r\n\r\nconst optionHList = O.getEq(hlist);\r\n\r\nexport function isActive(id: ID, state: WidgetState) {\r\n  return optionHList.equals(O.some(id), state.activeId);\r\n}\r\nexport function isFocused(id: ID, state: WidgetState) {\r\n  return optionHList.equals(O.some(id), state.focusedId);\r\n}\r\n\r\nexport function isCurrentlyActive(\r\n  ctx: WidgetBuilderState,\r\n  state: WidgetState\r\n): boolean {\r\n  return isActive(ctx.currentId, state);\r\n}\r\n\r\nexport function isCurrentlyPressed(\r\n  ctx: WidgetBuilderState,\r\n  state: WidgetState\r\n): boolean {\r\n  return optionHList.equals(O.some(ctx.currentId), state.pressedId);\r\n}\r\n\r\nexport function isCurrentlyFocused(\r\n  ctx: WidgetBuilderState,\r\n  state: WidgetState\r\n): boolean {\r\n  return optionHList.equals(O.some(ctx.currentId), state.focusedId);\r\n}\r\n\r\nexport function canActivate(\r\n  ctx: WidgetBuilderState,\r\n  state: WidgetState\r\n): boolean {\r\n  return O.isNone(state.activeId) && !isCurrentlyActive(ctx, state);\r\n}\r\nexport function canDeactivate(\r\n  ctx: WidgetBuilderState,\r\n  state: WidgetState\r\n): boolean {\r\n  return isCurrentlyActive(ctx, state);\r\n}\r\n","import * as hlist from \"../data/hlist\";\r\n\r\nexport type TranslableString = {\r\n  type: \"translable_string\";\r\n  strings: TemplateStringsArray;\r\n  values: string[];\r\n};\r\n\r\nexport const tr: (\r\n  strings: TemplateStringsArray,\r\n  ...values: string[]\r\n) => TranslableString = (strings, ...values) => ({\r\n  type: \"translable_string\",\r\n  strings,\r\n  values\r\n});\r\n\r\nexport type ID = hlist.HList<string>;\r\n\r\ntype LocationDSL = { row: number; column: number; flex: number };\r\n\r\nexport type DSL =\r\n  | { type: \"text\"; id: ID; text: TranslableString }\r\n  | { type: \"button\"; id: ID; text: TranslableString }\r\n  | { type: \"container\"; id: ID; children: DSL[] }\r\n  | { type: \"input\"; id: ID; value: string ; enabled: boolean};\r\n\r\nexport const text: (id: ID, text: TranslableString) => DSL = (id, text) => ({\r\n  type: \"text\",\r\n  id,\r\n  text\r\n});\r\nexport const container: (id: ID, children: DSL[]) => DSL = (id, children) => ({\r\n  type: \"container\",\r\n  id,\r\n  children\r\n});\r\nexport const button: (id: ID, text: TranslableString) => DSL = (id, text) => ({\r\n  type: \"button\",\r\n  id,\r\n  text\r\n});\r\nexport const input: (id: ID, value: string, enabled: boolean) => DSL = (\r\n  id,\r\n  value,\r\n  enabled\r\n) => ({ type: \"input\", id, value, enabled });\r\n","import { URIS, Kind } from \"fp-ts/lib/HKT\";\r\n\r\nexport type Next<U extends URIS, A> =\r\n  | { type: \"halt\" }\r\n  | { type: \"continue\"; state: A }\r\n  | { type: \"suspendAndResume\"; effect: Kind<U, A> };\r\n\r\nexport const halt: <U extends URIS, A>() => Next<U, A> = () => ({\r\n  type: \"halt\"\r\n});\r\nexport const cont: <U extends URIS, A>(state: A) => Next<U, A> = state => ({\r\n  type: \"continue\",\r\n  state\r\n});\r\nexport const suspendAndResume: <U extends URIS, A>(\r\n  effect: Kind<U, A>\r\n) => Next<U, A> = effect => ({ type: \"suspendAndResume\", effect });\r\n\r\nexport const fold: <U extends URIS, A, B>(\r\n  onContinue: (state: A) => B,\r\n  onSuspendAndResume: (effect: Kind<U, A>) => B,\r\n  onHalt: () => B\r\n) => (fa: Next<U, A>) => B = (\r\n  onContinue,\r\n  onResumeAndContinue,\r\n  onHalt\r\n) => fa => {\r\n  switch (fa.type) {\r\n    case \"continue\":\r\n      return onContinue(fa.state);\r\n    case \"suspendAndResume\":\r\n      return onResumeAndContinue(fa.effect);\r\n    case \"halt\":\r\n      return onHalt();\r\n    default:\r\n      throw Error(\"WTF!\");\r\n  }\r\n};\r\n\r\nexport const reduce: <U extends URIS, A>(\r\n  items: ((state: A) => Next<U, A>)[]\r\n) => (initialState: A) => Next<U, A> = transforms => initialState => {\r\n  let currentState = initialState;\r\n  let currentIndex = 0;\r\n  while (transforms.length > currentIndex) {\r\n    const proposedState = transforms[currentIndex](currentState);\r\n    switch (proposedState.type) {\r\n      case \"halt\":\r\n        break;\r\n      case \"continue\":\r\n        currentState = proposedState.state;\r\n        break;\r\n      case \"suspendAndResume\":\r\n        return proposedState;\r\n      default:\r\n        throw Error(\"WTF!\");\r\n    }\r\n    currentIndex++;\r\n  }\r\n  return currentState !== initialState ? cont(currentState) : halt();\r\n};\r\n","import * as S from \"fp-ts/lib/State\";\r\nimport * as C from \"./context\";\r\nimport * as D from \"./dsl\";\r\nimport * as O from \"fp-ts/lib/Ord\";\r\nimport * as H from \"../data/hlist\";\r\nimport * as N from \"../data/next\";\r\n\r\n\r\nexport interface Widget {\r\n  ui: D.DSL;\r\n  tick: (dsl: D.DSL) => (state: C.WidgetState) => N.Next<\"IO\", C.WidgetState>;\r\n}\r\n\r\nexport interface WidgetBuilder extends S.State<C.WidgetBuilderState, Widget> {}\r\n\r\nexport const widget: O.Ord<Widget> = {\r\n  equals: (a, b) => H.equals(a.ui.id, b.ui.id),\r\n  compare: (a, b) => 0\r\n};\r\n","import * as C from \"./core/context\";\r\nimport * as D from \"./core/dsl\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as S from \"fp-ts/lib/State\";\r\nimport * as A from \"fp-ts/lib/Array\";\r\nimport * as I from \"fp-ts/lib/IO\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport * as N from \"./data/next\";\r\nimport * as W from \"./core/widget\";\r\n\r\nconst immutableWidget = (_: D.DSL) => (s: C.WidgetState) => N.halt<\"IO\", C.WidgetState>()\r\n\r\nexport const tr = D.tr;\r\n\r\nexport const text: (text: D.TranslableString) => W.WidgetBuilder = text =>\r\n  S.gets<C.WidgetBuilderState, W.Widget>(ctx => ({\r\n    ui: D.text(ctx.currentId, text),\r\n    tick: immutableWidget\r\n  }));\r\n\r\nexport const button: (\r\n  text: D.TranslableString,\r\n  onPress: () => I.IO<void>\r\n) => W.WidgetBuilder = (text, onPress) =>\r\n  S.gets<C.WidgetBuilderState, W.Widget>(ctx => ({\r\n    ui: D.button(ctx.currentId, text),\r\n    tick: _ => state => {\r\n      const canActivate = C.canActivate(ctx, state);\r\n      const isCurrentlyPressed = C.isCurrentlyPressed(ctx, state);\r\n      const isCurrentlyFocused = C.isCurrentlyFocused(ctx, state);\r\n      const wasPressedBefore = state.activeIdWasPressedBefore;\r\n      const isCurrentlyActive = C.isCurrentlyActive(ctx, state);\r\n\r\n      if (isCurrentlyPressed && !isCurrentlyFocused) {\r\n        console.log(\"button: focusing\");\r\n        return N.cont(\r\n          pipe(\r\n            state,\r\n            C.setFocusedId(O.some(ctx.currentId))\r\n          )\r\n        );\r\n      }\r\n\r\n      if (canActivate && isCurrentlyFocused && isCurrentlyPressed) {\r\n        console.log(\"button: activating\");\r\n        return N.cont(\r\n          pipe(\r\n            state,\r\n            C.setActiveId(O.some(ctx.currentId))\r\n          )\r\n        );\r\n      }\r\n\r\n      if (isCurrentlyActive && !wasPressedBefore) {\r\n        console.log(\"button: onPress\");\r\n        return N.suspendAndResume(\r\n          pipe(\r\n            onPress(),\r\n            I.map(_ =>\r\n              pipe(\r\n                state,\r\n                C.setActiveIdWasPressedBefore(true)\r\n              )\r\n            )\r\n          )\r\n        );\r\n      }\r\n\r\n      if (isCurrentlyActive && !isCurrentlyPressed) {\r\n        console.log(\"button: deactivating\");\r\n        return N.cont(\r\n          pipe(\r\n            state,\r\n            C.setActiveId(O.none)\r\n          )\r\n        );\r\n      }\r\n\r\n      return N.halt();\r\n    }\r\n  }));\r\n\r\nexport const container: (...builders: W.WidgetBuilder[]) => W.WidgetBuilder = (\r\n  ...builders\r\n) =>\r\n  pipe(\r\n    A.array.sequence(S.state)(builders),\r\n    S.map(A.sort(W.widget)),\r\n    S.chain(widgets =>\r\n      S.gets<C.WidgetBuilderState, W.Widget>(ctx => ({\r\n        ui: D.container(ctx.currentId, widgets.map(w => w.ui)),\r\n        tick: dsl => initialState =>\r\n          N.reduce(widgets.map(w => w.tick(w.ui)))(initialState)\r\n      }))\r\n    )\r\n  );\r\n\r\nexport const input: (\r\n  value: string,\r\n  onChange: (newValue: string) => I.IO<void>,\r\n  valid: boolean,\r\n  isFormatValid: (bufferValue: string) => boolean\r\n) => W.WidgetBuilder = (value, onChange, valid, isFormatValid) =>\r\n  S.gets<C.WidgetBuilderState, W.Widget>(ctx => ({\r\n    ui: D.input(ctx.currentId, value, C.getEnabled(ctx)),\r\n    tick: _ => state => {\r\n      const canActivate = C.canActivate(ctx, state);\r\n      const isCurrentlyActive = C.isCurrentlyActive(ctx, state);\r\n      const isCurrentlyFocused = C.isCurrentlyFocused(ctx, state);\r\n      const canDeactivate = C.canDeactivate(ctx, state);\r\n      const enabled = C.getEnabled(ctx);\r\n\r\n      // if disabled, forcefully deactivate\r\n      if (isCurrentlyActive && !enabled) {\r\n        return N.cont(\r\n          pipe(\r\n            state,\r\n            C.setActiveId(O.some(ctx.currentId))\r\n          )\r\n        );\r\n      }\r\n\r\n      // if enabled, allows logic\r\n      if (enabled) {\r\n        if (!isCurrentlyActive && isCurrentlyFocused && canActivate) {\r\n          // activate the control\r\n          return N.cont(\r\n            pipe(\r\n              state,\r\n              C.setActiveId(O.some(ctx.currentId))\r\n            )\r\n          );\r\n        } else if (isCurrentlyActive && !isCurrentlyFocused && canDeactivate) {\r\n          // if there is no pending buffer, release the control\r\n          if (O.isNone(state.inputBuffer) && valid) {\r\n            return N.cont(\r\n              pipe(\r\n                state,\r\n                C.setActiveId(O.none)\r\n              )\r\n            );\r\n          }\r\n\r\n          // check if the format of the buffer is ok\r\n          const bufferValue = O.getOrElse(() => value)(state.inputBuffer);\r\n          if (isFormatValid(bufferValue)) {\r\n            console.log(\"input: run onChange\");\r\n            return N.suspendAndResume(\r\n              pipe(\r\n                onChange(bufferValue),\r\n                I.map(() => C.setInputBuffer(O.none)(state))\r\n              )\r\n            );\r\n          }\r\n        }\r\n      }\r\n\r\n      return N.halt();\r\n    }\r\n  }));\r\n\r\nexport const number: (\r\n  value: number,\r\n  onChange: (newValue: number) => I.IO<void>,\r\n  valid: boolean\r\n) => W.WidgetBuilder = (value, onChange, valid) =>\r\n  input(\r\n    value.toFixed(0),\r\n    newValue => onChange(parseInt(newValue)),\r\n    valid,\r\n    value => !isNaN(parseInt(value))\r\n  );\r\n\r\nexport const string: (\r\n  value: string,\r\n  onChange: (newValue: string) => I.IO<void>,\r\n  valid: boolean\r\n) => W.WidgetBuilder = (value, onChange, valid) =>\r\n  input(value, onChange, valid, value => true);\r\n","import * as C from \"./core/context\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as S from \"fp-ts/lib/State\";\r\nimport * as W from \"./core/widget\";\r\n\r\nexport const id: (\r\n  id: string\r\n) => (widget: W.WidgetBuilder) => W.WidgetBuilder = id => widget =>\r\n  pipe(\r\n    S.modify(C.pushId(id)),\r\n    S.chain(() => widget),\r\n    S.chainFirst(() => S.modify(C.popId()))\r\n  );\r\n\r\nexport const enabled: (\r\n  isEnabled: boolean\r\n) => (widget: W.WidgetBuilder) => W.WidgetBuilder = isEnabled => widget =>\r\n  pipe(\r\n    S.gets(C.getEnabled),\r\n    S.chain<C.WidgetBuilderState, boolean, W.Widget>(prevEnabled =>\r\n      pipe(\r\n        S.modify(C.setEnabled(isEnabled)),\r\n        S.chain(() => widget),\r\n        S.chainFirst(() => S.modify(C.setEnabled(prevEnabled)))\r\n      )\r\n    )\r\n  );\r\n","import * as React from \"react\";\r\nimport * as D from \"../core/dsl\";\r\nimport * as C from \"../core/context\";\r\nimport * as I from \"fp-ts/lib/IO\";\r\nimport * as O from \"fp-ts/lib/Option\";\r\nimport * as CW from \"../core/widget\";\r\nimport * as hlist from \"../data/hlist\";\r\nimport * as rxOp from \"rxjs/operators\";\r\nimport * as RR from \"./renderer\";\r\nimport { TextInput, Text, Button } from \"react-native\";\r\nimport * as RX from \"rxjs\";\r\n\r\nconst StateContext = React.createContext(RX.of(C.initialWidgetState));\r\n\r\ntype ComponentProps = {\r\n  dsl: D.DSL;\r\n  dispatch: (f: (state: C.WidgetState) => C.WidgetState) => I.IO<void>;\r\n  update: (f: (state: C.WidgetState) => C.WidgetState) => I.IO<void>;\r\n};\r\n\r\nfunction render(props: ComponentProps): JSX.Element {\r\n  switch (props.dsl.type) {\r\n    case \"input\":\r\n      return <RenderInput {...props} key={hlist.toString(props.dsl.id)} />;\r\n    case \"container\":\r\n      return <RenderContainer {...props} key={hlist.toString(props.dsl.id)} />;\r\n    case \"text\":\r\n      return <RenderText {...props} key={hlist.toString(props.dsl.id)} />;\r\n    case \"button\":\r\n      return <RenderButton {...props} key={hlist.toString(props.dsl.id)} />;\r\n  }\r\n  return <React.Fragment>{JSON.stringify(props.dsl)}</React.Fragment>;\r\n}\r\n\r\nfunction translate(t: D.TranslableString): string {\r\n  // TODO: this is just a stub, needs to handle number and date formatting in a localized way.\r\n  return t.strings.map((s, i) => s + (t.values[i] || \"\")).join(\"\");\r\n}\r\n\r\nfunction useObservable<T>(observable$: RX.Observable<T>): T | undefined;\r\nfunction useObservable<T>(observable$: RX.Observable<T>, initialValue: T): T;\r\nfunction useObservable<T>(\r\n  observable$: RX.Observable<T>,\r\n  initialValue?: T\r\n): T | undefined {\r\n  const [value, update] = React.useState<T | undefined>(initialValue);\r\n\r\n  React.useLayoutEffect(() => {\r\n    const s = observable$.subscribe(update);\r\n    return () => s.unsubscribe();\r\n  }, [observable$]);\r\n\r\n  return value;\r\n}\r\n\r\nexport const RenderInput = React.memo(function InputRenderer(\r\n  props: ComponentProps\r\n) {\r\n  const state$ = React.useContext(StateContext);\r\n  const { dispatch, update } = props;\r\n  const { id } = props.dsl;\r\n  const value = (props.dsl as any).value || \"\";\r\n  const idSerialized = hlist.toString(id);\r\n  const onChangeText = React.useMemo(\r\n    () => (newText: string) => update(C.setInputBuffer(O.some(newText)))(),\r\n    [update]\r\n  );\r\n  const onFocus = React.useMemo(\r\n    () => dispatch(C.setFocusedId(O.some(id))),\r\n    [dispatch, idSerialized]\r\n  );\r\n  const onBlur = React.useMemo(() => dispatch(C.setFocusedId(O.none)), [\r\n    dispatch,\r\n    idSerialized\r\n  ]);\r\n  const ref = React.useRef<TextInput>();\r\n\r\n  const isActive$ = React.useMemo(\r\n    () => state$.pipe(rxOp.map(state => C.isActive(id, state))),\r\n    [state$, idSerialized]\r\n  );\r\n  const isFocused$ = React.useMemo(\r\n    () => state$.pipe(rxOp.map(state => C.isFocused(id, state))),\r\n    [state$, idSerialized]\r\n  );\r\n  const rawValue$ = React.useMemo(\r\n    () =>\r\n      state$.pipe(\r\n        rxOp.map(state =>\r\n          C.isActive(id, state)\r\n            ? O.getOrElse(() => value)(state.inputBuffer)\r\n            : value\r\n        )\r\n      ),\r\n    [state$, idSerialized, value]\r\n  );\r\n\r\n  const isActive = useObservable(isActive$, false);\r\n  const isFocused = useObservable(isFocused$, false);\r\n  const rawValue = useObservable(rawValue$, value);\r\n\r\n  React.useLayoutEffect(() => {\r\n    if (isFocused && ref.current && !ref.current.isFocused()) {\r\n      ref.current.focus();\r\n      console.log(\"forced focus to\", idSerialized);\r\n    }\r\n  });\r\n\r\n  if (props.dsl.type !== \"input\") return null;\r\n\r\n  return (\r\n      <TextInput\r\n        ref={ref as any}\r\n        editable={isActive}\r\n        value={rawValue}\r\n        onChangeText={isActive ? onChangeText : undefined}\r\n        onFocus={!isFocused ? onFocus : undefined}\r\n        onBlur={isFocused ? onBlur : undefined}\r\n        autoCapitalize=\"none\"\r\n      />\r\n  );\r\n});\r\nRenderInput.displayName = 'DSL(Input)'\r\n\r\nexport const RenderText = React.memo(function TextRenderer(\r\n  props: ComponentProps\r\n) {\r\n  if (props.dsl.type !== \"text\") return null;\r\n  return <Text>{translate(props.dsl.text)}</Text>;\r\n});\r\nRenderText.displayName = 'DSL(Text)'\r\n\r\nexport const RenderButton = React.memo(function ButtonRenderer(\r\n  props: ComponentProps\r\n) {\r\n  if (props.dsl.type !== \"button\") return null;\r\n  return (\r\n    <Button\r\n      onPress={() => {\r\n        props.dispatch(C.setPressedId(O.some(props.dsl.id)))();\r\n        props.dispatch(C.setPressedId(O.none))();\r\n      }}\r\n      title={translate(props.dsl.text)}\r\n    />\r\n  );\r\n});\r\nRenderButton.displayName = 'DSL(Button)'\r\n\r\nexport const RenderContainer = React.memo(function ContainerRenderer(\r\n  props: ComponentProps\r\n) {\r\n  if (props.dsl.type !== \"container\") return null;\r\n  return (\r\n    <React.Fragment key={hlist.toString(props.dsl.id)}>\r\n      {props.dsl.children.map((dsl, i) => render({ ...props, dsl }))}\r\n    </React.Fragment>\r\n  );\r\n});\r\nRenderContainer.displayName = 'DSL(Container)'\r\n\r\nexport const RenderDsl = React.memo(function DslRenderer(\r\n  props: ComponentProps\r\n) {\r\n  return render(props);\r\n});\r\n\r\nexport class AppRunner<A> extends React.Component<\r\n  { getApp: I.IO<CW.WidgetBuilder> },\r\n  C.WidgetState\r\n> {\r\n  state = C.initialWidgetState;\r\n  state$ = new RX.BehaviorSubject(this.state);\r\n  app: CW.Widget;\r\n\r\n  constructor(props: { getApp: I.IO<CW.WidgetBuilder> }) {\r\n    super(props);\r\n    this.app = this.getApp(props);\r\n  }\r\n\r\n  getApp(props: { getApp: I.IO<CW.WidgetBuilder> }) {\r\n    return props.getApp()(C.initialWidgetBuilderState)[0];\r\n  }\r\n\r\n  eventLoop: (initialState: C.WidgetState) => C.WidgetState = initialState => {\r\n    let lastState = initialState;\r\n    let keepAlive = true;\r\n    let numLoops = 0;\r\n    let stateList: C.WidgetState[] = [];\r\n    while (keepAlive) {\r\n      const nextState = this.app.tick(this.app.ui)(lastState);\r\n      switch (nextState.type) {\r\n        case \"halt\":\r\n          keepAlive = false;\r\n          break;\r\n        case \"continue\":\r\n          lastState = nextState.state;\r\n          stateList.push(lastState);\r\n          break;\r\n        case \"suspendAndResume\":\r\n          lastState = nextState.effect();\r\n          stateList.push(lastState);\r\n          this.app = this.getApp(this.props);\r\n          break;\r\n      }\r\n      numLoops++;\r\n      if (numLoops > 10) {\r\n        keepAlive = false;\r\n        console.log(stateList);\r\n        console.warn(\"end of max loop count\");\r\n      }\r\n    }\r\n    return lastState;\r\n  };\r\n\r\n  componentWillMount() {\r\n    this.setState(state => this.eventLoop(state));\r\n  }\r\n\r\n  dispatch: (\r\n    f: (state: C.WidgetState) => C.WidgetState\r\n  ) => I.IO<void> = f => () =>\r\n    this.setState(state => {\r\n      const newState = this.eventLoop(f(state));\r\n      this.state$.next(newState);\r\n      return newState;\r\n    });\r\n\r\n  update: (\r\n    f: (state: C.WidgetState) => C.WidgetState\r\n  ) => I.IO<void> = f => () =>\r\n    this.setState(state => {\r\n      const newState = f(state);\r\n      this.state$.next(newState);\r\n      return newState;\r\n    });\r\n\r\n  render() {\r\n    return (\r\n      <StateContext.Provider value={this.state$}>\r\n        <RR.RenderDsl\r\n          dsl={this.app.ui}\r\n          dispatch={this.dispatch}\r\n          update={this.update}\r\n        />\r\n      </StateContext.Provider>\r\n    );\r\n  }\r\n}\r\n","import * as W from \"./widgets\";\r\nimport * as A from \"./attributes\";\r\nimport * as React from \"react\";\r\nimport * as I from \"fp-ts/lib/IO\";\r\nimport * as RR from \"./react/renderer\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\n\r\ntype Model = {\r\n  name: string;\r\n  surname: string;\r\n  age: number;\r\n};\r\n\r\nfunction render(model: Model) {\r\n  let spamTest: string[] = [];\r\n  for (let i = 0; i < 1000; i++) {\r\n    spamTest.push(\"\" + i);\r\n  }\r\n  return (update: (newModel: Model) => I.IO<void>) =>\r\n    W.container(\r\n      pipe(\r\n        W.container(\r\n          W.text(W.tr`Età:`),\r\n          pipe(\r\n            W.number(model.age, age => update({ ...model, age }), true),\r\n            A.id(\"age\")\r\n          )\r\n        ),\r\n        A.id(\"eta\")\r\n      ),\r\n      pipe(\r\n        W.container(\r\n          W.text(W.tr`Nome:`),\r\n          pipe(\r\n            W.string(model.name, name => update({ ...model, name }), true),\r\n            A.id(\"name\"),\r\n            A.enabled(model.age <= 18)\r\n          )\r\n        ),\r\n        A.id(\"name\")\r\n      ),\r\n      pipe(\r\n        W.container(\r\n          W.text(W.tr`Cognome:`),\r\n          pipe(\r\n            W.string(\r\n              model.surname,\r\n              surname => update({ ...model, surname }),\r\n              true\r\n            ),\r\n            A.id(\"surname\")\r\n          )\r\n        ),\r\n        A.id(\"surname\")\r\n      ),\r\n      pipe(\r\n        W.text(\r\n          W.tr`Ciao ${model.name} ${\r\n            model.surname\r\n          }, complimenti per i tuoi ${model.age.toFixed(0)} anni!`\r\n        ),\r\n        A.id(\"sum\")\r\n      ),\r\n      pipe(\r\n        W.button(W.tr`Salva`, () => () => console.log(model)),\r\n        A.id(\"button\")\r\n      ),\r\n      ...spamTest.map((_, i) =>\r\n        pipe(\r\n          W.container(\r\n            pipe(W.text(W.tr`Nome:`), A.id(\"lol\")),\r\n            pipe(\r\n              W.string(model.name, name => update({ ...model, name }), true),\r\n              A.id(\"name\" + i)\r\n            )\r\n          ),\r\n          A.id(\"div\" + i)\r\n        )\r\n      )\r\n    );\r\n}\r\n\r\nlet appModel: Model = {\r\n  name: \"\",\r\n  surname: \"\",\r\n  age: 0\r\n};\r\n\r\nexport function App() {\r\n  return (\r\n    <RR.AppRunner\r\n      getApp={() => {\r\n        return render(appModel)(newValue => {\r\n          console.log(\"STATE UPDATE\", newValue);\r\n          return () => {\r\n            console.log(\"STATE UPDATED\", newValue);\r\n            appModel = newValue;\r\n          };\r\n        });\r\n      }}\r\n    />\r\n  );\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport * as S from './lib/sample'\r\n\r\nReactDOM.render(<S.App />, document.getElementById(\"root\"))\r\n\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n\r\n"],"sourceRoot":""}